[{"categories":["WEB"],"content":"Go增加Redis缓存机制方案 ","date":"2022-11-08","objectID":"/posts/go%E5%A2%9E%E5%8A%A0redis%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/:1:0","series":null,"tags":["Go","Redis","Singleflight"],"title":"Go增加Redis缓存机制","uri":"/posts/go%E5%A2%9E%E5%8A%A0redis%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/#go增加redis缓存机制方案"},{"categories":["WEB"],"content":"增加缓存机制 缓存基于redis，以数据集为单位组织存储 根据查询条件序列化生成单独的key，查询数据作为内容，组成缓存的最小单元 数据查询时先进行redis缓存查询，如果命中，直接取缓存内容返回，未命中则继续执行后续程序，从数据库中查询内容，查询成功后存入缓存，以待下次使用 缓存模块提供方法 //存储缓存方法 func (c *Cache) HSet(ctx context.Context, datasetId int, key string, value interface{}) //获取缓存方法 func (c *Cache) HGet(ctx context.Context, datasetId int, key string) string //删除缓存，以数据集为单位 func (c *Cache) Del(ctx context.Context, datasetId int) 缓存击穿与并发解决方案 为应对高并发和缓存击穿风险，采用singleflight技术。singleflght使用协程技术，可以保证相同的查询在同一时间只有一个进程可以访问查询程序，其余的进程则会在查询完成后共享查询结果 singleflght可以在缓存查询前调用，以减缓高并发对缓存造成的压力，同样也可以减少缓存击穿时对数据库造成的冲击 singleflight代码： import \"sync\" type call struct { wg sync.WaitGroup val interface{} err error } type Group struct { mu sync.Mutex m map[string]*call } func (g *Group) Do(key string, fn func() (interface{}, error)) (interface{}, error) { g.mu.Lock() if g.m == nil { g.m = make(map[string]*call) } if c, ok := g.m[key]; ok { g.mu.Unlock() c.wg.Wait() return c.val, c.err } c := new(call) c.wg.Add(1) g.m[key] = c g.mu.Unlock() c.val, c.err = fn() c.wg.Done() g.mu.Lock() delete(g.m, key) g.mu.Unlock() return c.val, c.err } 使用示例： import ( \"testing\" ) func TestDo(t *testing.T) { var g Group v, err := g.Do(\"key\", func() (interface{}, error) { return \"bar\", nil }) if v != \"bar\" || err != nil { t.Errorf(\"Do v = %v, error = %v\", v, err) } } ","date":"2022-11-08","objectID":"/posts/go%E5%A2%9E%E5%8A%A0redis%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/:1:1","series":null,"tags":["Go","Redis","Singleflight"],"title":"Go增加Redis缓存机制","uri":"/posts/go%E5%A2%9E%E5%8A%A0redis%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/#增加缓存机制"},{"categories":["WEB"],"content":"增加缓存机制 缓存基于redis，以数据集为单位组织存储 根据查询条件序列化生成单独的key，查询数据作为内容，组成缓存的最小单元 数据查询时先进行redis缓存查询，如果命中，直接取缓存内容返回，未命中则继续执行后续程序，从数据库中查询内容，查询成功后存入缓存，以待下次使用 缓存模块提供方法 //存储缓存方法 func (c *Cache) HSet(ctx context.Context, datasetId int, key string, value interface{}) //获取缓存方法 func (c *Cache) HGet(ctx context.Context, datasetId int, key string) string //删除缓存，以数据集为单位 func (c *Cache) Del(ctx context.Context, datasetId int) 缓存击穿与并发解决方案 为应对高并发和缓存击穿风险，采用singleflight技术。singleflght使用协程技术，可以保证相同的查询在同一时间只有一个进程可以访问查询程序，其余的进程则会在查询完成后共享查询结果 singleflght可以在缓存查询前调用，以减缓高并发对缓存造成的压力，同样也可以减少缓存击穿时对数据库造成的冲击 singleflight代码： import \"sync\" type call struct { wg sync.WaitGroup val interface{} err error } type Group struct { mu sync.Mutex m map[string]*call } func (g *Group) Do(key string, fn func() (interface{}, error)) (interface{}, error) { g.mu.Lock() if g.m == nil { g.m = make(map[string]*call) } if c, ok := g.m[key]; ok { g.mu.Unlock() c.wg.Wait() return c.val, c.err } c := new(call) c.wg.Add(1) g.m[key] = c g.mu.Unlock() c.val, c.err = fn() c.wg.Done() g.mu.Lock() delete(g.m, key) g.mu.Unlock() return c.val, c.err } 使用示例： import ( \"testing\" ) func TestDo(t *testing.T) { var g Group v, err := g.Do(\"key\", func() (interface{}, error) { return \"bar\", nil }) if v != \"bar\" || err != nil { t.Errorf(\"Do v = %v, error = %v\", v, err) } } ","date":"2022-11-08","objectID":"/posts/go%E5%A2%9E%E5%8A%A0redis%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/:1:1","series":null,"tags":["Go","Redis","Singleflight"],"title":"Go增加Redis缓存机制","uri":"/posts/go%E5%A2%9E%E5%8A%A0redis%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/#缓存模块提供方法"},{"categories":["WEB"],"content":"增加缓存机制 缓存基于redis，以数据集为单位组织存储 根据查询条件序列化生成单独的key，查询数据作为内容，组成缓存的最小单元 数据查询时先进行redis缓存查询，如果命中，直接取缓存内容返回，未命中则继续执行后续程序，从数据库中查询内容，查询成功后存入缓存，以待下次使用 缓存模块提供方法 //存储缓存方法 func (c *Cache) HSet(ctx context.Context, datasetId int, key string, value interface{}) //获取缓存方法 func (c *Cache) HGet(ctx context.Context, datasetId int, key string) string //删除缓存，以数据集为单位 func (c *Cache) Del(ctx context.Context, datasetId int) 缓存击穿与并发解决方案 为应对高并发和缓存击穿风险，采用singleflight技术。singleflght使用协程技术，可以保证相同的查询在同一时间只有一个进程可以访问查询程序，其余的进程则会在查询完成后共享查询结果 singleflght可以在缓存查询前调用，以减缓高并发对缓存造成的压力，同样也可以减少缓存击穿时对数据库造成的冲击 singleflight代码： import \"sync\" type call struct { wg sync.WaitGroup val interface{} err error } type Group struct { mu sync.Mutex m map[string]*call } func (g *Group) Do(key string, fn func() (interface{}, error)) (interface{}, error) { g.mu.Lock() if g.m == nil { g.m = make(map[string]*call) } if c, ok := g.m[key]; ok { g.mu.Unlock() c.wg.Wait() return c.val, c.err } c := new(call) c.wg.Add(1) g.m[key] = c g.mu.Unlock() c.val, c.err = fn() c.wg.Done() g.mu.Lock() delete(g.m, key) g.mu.Unlock() return c.val, c.err } 使用示例： import ( \"testing\" ) func TestDo(t *testing.T) { var g Group v, err := g.Do(\"key\", func() (interface{}, error) { return \"bar\", nil }) if v != \"bar\" || err != nil { t.Errorf(\"Do v = %v, error = %v\", v, err) } } ","date":"2022-11-08","objectID":"/posts/go%E5%A2%9E%E5%8A%A0redis%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/:1:1","series":null,"tags":["Go","Redis","Singleflight"],"title":"Go增加Redis缓存机制","uri":"/posts/go%E5%A2%9E%E5%8A%A0redis%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/#缓存击穿与并发解决方案"},{"categories":["WEB"],"content":"使用PHP对PDF格式文件的图片转换 ","date":"2022-09-08","objectID":"/posts/php%E5%AE%9E%E7%8E%B0pdf%E8%BD%AC%E5%9B%BE%E7%89%87/:1:0","series":null,"tags":["PHP","ImageMagick","Ghostscript"],"title":"PHP实现PDF转图片","uri":"/posts/php%E5%AE%9E%E7%8E%B0pdf%E8%BD%AC%E5%9B%BE%E7%89%87/#使用php对pdf格式文件的图片转换"},{"categories":["WEB"],"content":"功能概述 此功能操作需要ImageMagick、Ghostscript、imagick的PHP扩展模块来共同完成，下面先详细介绍下三者的关联： ImageMagick是第三方的图片处理软件，类似GD，官网，中文介绍。 imagick是php的一个扩展模块，它调用ImageMagick提供的API来进行图片的操作，官网。 Ghostscript是一套建基于Adobe、PostScript及可移植文档格式（PDF）的页面描述语言等而编译成的免费软件，官网。Ghostscript最初是以商业软件形式在PC市场上发售，并称之为“GoScript”。但由于速度太慢（半小时一版A4），销量极差。后来有心人买下了版权，并改在Linux上开发，成为了今日的Ghostscript。已经从Linux版本移植到其他操作系统，如其他Unix、Mac OS X、VMS、Windows、OS/2和Mac OS classic。 三者关系，ImageMagick无法直接实现pdf文档到图片的转换，需要借助于gostscript软件包，然后由ImageMagick处理图片，最后如果是选择PHP开发就要使用imagick对接ImageMagick。 ","date":"2022-09-08","objectID":"/posts/php%E5%AE%9E%E7%8E%B0pdf%E8%BD%AC%E5%9B%BE%E7%89%87/:1:1","series":null,"tags":["PHP","ImageMagick","Ghostscript"],"title":"PHP实现PDF转图片","uri":"/posts/php%E5%AE%9E%E7%8E%B0pdf%E8%BD%AC%E5%9B%BE%E7%89%87/#功能概述"},{"categories":["WEB"],"content":"软件版本说明 PHP 7.2.19 ImageMagick 7.1.0-47 Ghostscript 9.56.1 imagick 3.7.0 ","date":"2022-09-08","objectID":"/posts/php%E5%AE%9E%E7%8E%B0pdf%E8%BD%AC%E5%9B%BE%E7%89%87/:1:2","series":null,"tags":["PHP","ImageMagick","Ghostscript"],"title":"PHP实现PDF转图片","uri":"/posts/php%E5%AE%9E%E7%8E%B0pdf%E8%BD%AC%E5%9B%BE%E7%89%87/#软件版本说明"},{"categories":["WEB"],"content":"安装ImageMagick 下载ImageMagick wget https://imagemagick.org/archive/ImageMagick.tar.gz 解压安装 tar zxvf ImageMagick.tar.gz cd ImageMagick-7.1.0-47/ ./configure --prefix=/usr/local/imagemagick make \u0026\u0026 make install ","date":"2022-09-08","objectID":"/posts/php%E5%AE%9E%E7%8E%B0pdf%E8%BD%AC%E5%9B%BE%E7%89%87/:1:3","series":null,"tags":["PHP","ImageMagick","Ghostscript"],"title":"PHP实现PDF转图片","uri":"/posts/php%E5%AE%9E%E7%8E%B0pdf%E8%BD%AC%E5%9B%BE%E7%89%87/#安装imagemagick"},{"categories":["WEB"],"content":"安装PHP的imagick拓展 下载imagick wget https://pecl.php.net/get/imagick-3.7.0.tgz 解压安装 tar zxvf imagick-3.7.0.tgz cd imagick-3.7.0/ /usr/local/php/bin/phpize #用phpize生成 ln -s /usr/local/imagemagick/include/ImageMagick-7 /usr/local/imagemagick/include/ImageMagick #ImageMagick6.8以上版本为/usr/local/include/ImageMagick-X,在configure之前先做下软连接 ./configure --with-php-config=/usr/local/php/bin/php-config --with-imagick=/usr/local/imagemagick #编译 make \u0026\u0026 make install #安装 查看版本 php --ri imagick imagick module =\u003e enabled imagick module version =\u003e 3.7.0 PHP imagick扩展安装可能会遇到的问题解决：configure通过,在make时出现错误error: wand/MagickWand.h: No such file or directory，解决方法： yum install gtk2-devel #https://pkgs.org/download/gtk2-devel export PKG_CONFIG_PATH=/usr/local/imagemagick/lib/pkgconfig/ ","date":"2022-09-08","objectID":"/posts/php%E5%AE%9E%E7%8E%B0pdf%E8%BD%AC%E5%9B%BE%E7%89%87/:1:4","series":null,"tags":["PHP","ImageMagick","Ghostscript"],"title":"PHP实现PDF转图片","uri":"/posts/php%E5%AE%9E%E7%8E%B0pdf%E8%BD%AC%E5%9B%BE%E7%89%87/#安装php的imagick拓展"},{"categories":["WEB"],"content":"安装Ghostscript 下载Ghostscript wget https://github.com/ArtifexSoftware/ghostpdl-downloads/releases/download/gs9561/ghostscript-9.56.1.tar.gz 安装Ghostscript tar -xzf ghostscript-9.56.1.tar.gz cd ghostscript-9.56.1 ./configure make \u0026\u0026 make install 测试gs gs -dQUIET -dNOSAFER -dBATCH -sDEVICE=pngalpha -dNOPAUSE -dNOPROMPT -sOutputFile=/home/wwwroot/demo/a%d.png test.pdf # sOutputFile=图片生成路径 PDF文件路径 ","date":"2022-09-08","objectID":"/posts/php%E5%AE%9E%E7%8E%B0pdf%E8%BD%AC%E5%9B%BE%E7%89%87/:1:5","series":null,"tags":["PHP","ImageMagick","Ghostscript"],"title":"PHP实现PDF转图片","uri":"/posts/php%E5%AE%9E%E7%8E%B0pdf%E8%BD%AC%E5%9B%BE%E7%89%87/#安装ghostscript"},{"categories":["WEB"],"content":"PHP实现PDF转图片实例 代码块 $pdf = \"/home/demo/test.pdf\"; // PDF文件路径 $path = \"/home/demo/imgs/\"; // 图片生成路径 if(!extension_loaded('imagick')) { return false; } if (!file_exists($pdf)) { return false; } $im = new \\Imagick(); $im-\u003esetResolution(120, 120); // 设置分辨率，值越大分辨率越高 $im-\u003esetCompressionQuality(100); // 压缩比1-100，100压缩比最低 $im-\u003ereadImage($pdf); $return = []; foreach ($im as $k =\u003e $v) { // 循环输出图片 $v-\u003esetImageFormat('png'); $fileName = $path . md5($k . time()) . '.png'; if ($v-\u003ewriteImage($fileName) == true) { $return[] = $fileName; } } ","date":"2022-09-08","objectID":"/posts/php%E5%AE%9E%E7%8E%B0pdf%E8%BD%AC%E5%9B%BE%E7%89%87/:1:6","series":null,"tags":["PHP","ImageMagick","Ghostscript"],"title":"PHP实现PDF转图片","uri":"/posts/php%E5%AE%9E%E7%8E%B0pdf%E8%BD%AC%E5%9B%BE%E7%89%87/#php实现pdf转图片实例"},{"categories":["Web"],"content":"使用DoIt主题进行hugo server时报错，问题处理流程如下 ","date":"2022-06-13","objectID":"/posts/hugo%E9%83%A8%E7%BD%B2%E6%8A%A5%E9%94%99/:1:0","series":null,"tags":["hugo","DoIt"],"title":"Hugo+DoIt部署报错","uri":"/posts/hugo%E9%83%A8%E7%BD%B2%E6%8A%A5%E9%94%99/#使用doit主题进行hugo-server时报错问题处理流程如下"},{"categories":["Web"],"content":"错误信息描述 $ hugo server Error: add site dependencies: load resources: loading templates: \"/themes/DoIt/layouts/partials/meta/author.html:8:1\": parse failed: template: partials/meta/author.html:8: unclosed action ","date":"2022-06-13","objectID":"/posts/hugo%E9%83%A8%E7%BD%B2%E6%8A%A5%E9%94%99/:1:1","series":null,"tags":["hugo","DoIt"],"title":"Hugo+DoIt部署报错","uri":"/posts/hugo%E9%83%A8%E7%BD%B2%E6%8A%A5%E9%94%99/#错误信息描述"},{"categories":["Web"],"content":"安装最新版本环境变量 查看当前版本 $ hugo version Hugo Static Site Generator v0.68.3/extended linux/amd64 BuildDate: 2020-03-25T06:15:45Z 查询并下载最新发行版本，本文使用v0.100.2版本 以linux ubuntu为例，查看hugo环境变量路径，进行替换即可 $ whereis hugo hugo: /usr/bin/hugo /usr/share/man/man1/hugo.1.gz $ mv /download/hugo /usr/bin $ chmod 755 /usr/bin/hugo $ hugo version hugo v0.100.2-d25cb2943fd94ecf781412aeff9682d5dc62e284 linux/amd64 BuildDate=2022-06-08T10:25:57Z VendorInfo=gohugoio 重新hugo server正常 Start building sites … hugo v0.100.2-d25cb2943fd94ecf781412aeff9682d5dc62e284 linux/amd64 BuildDate=2022-06-08T10:25:57Z VendorInfo=gohugoio | ZH-CN -------------------+-------- Pages | 32 Paginator pages | 0 Non-page files | 0 Static files | 83 Processed images | 0 Aliases | 12 Sitemaps | 1 Cleaned | 0 Total in 6615 ms ","date":"2022-06-13","objectID":"/posts/hugo%E9%83%A8%E7%BD%B2%E6%8A%A5%E9%94%99/:1:2","series":null,"tags":["hugo","DoIt"],"title":"Hugo+DoIt部署报错","uri":"/posts/hugo%E9%83%A8%E7%BD%B2%E6%8A%A5%E9%94%99/#安装最新版本环境变量"},{"categories":["开发"],"content":"golang检查数组中是否存在某个值 类似PHP用的in_array功能实现 in_array(mixed $needle, array $haystack, bool $strict = false): bool 在Go 1.18 版本支持泛型以后，可以在pkg.go.dev中的slices包下查找Contains方法用作实现,例如： package main import ( \"fmt\" \"golang.org/x/exp/slices\" ) func main() { var date string = \"createdAt\" dateType := []string{\"createdAt\", \"updatedAt\"} if slices.Contains[string](dateType, date) { fmt.Println(\"yes\") } else { fmt.Println(\"no\") } } ","date":"2022-06-10","objectID":"/posts/golang%E6%A3%80%E6%9F%A5%E6%95%B0%E7%BB%84%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9F%90%E4%B8%AA%E5%80%BC/:1:0","series":null,"tags":["Go"],"title":"GoLang检查数组中是否存在某个值","uri":"/posts/golang%E6%A3%80%E6%9F%A5%E6%95%B0%E7%BB%84%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9F%90%E4%B8%AA%E5%80%BC/#golang检查数组中是否存在某个值"},{"categories":["运维"],"content":"使用Compose对TP5进行部署 ","date":"2022-05-26","objectID":"/posts/docker-tp5%E9%83%A8%E7%BD%B2/:1:0","series":null,"tags":["Docker","Compose","PHP","Thinkphp"],"title":"Docker+TP5部署","uri":"/posts/docker-tp5%E9%83%A8%E7%BD%B2/#使用compose对tp5进行部署"},{"categories":["运维"],"content":"软件版本说明 Nginx 1.16 PHP 7.2 CentOS 7.9（已安装） Docker 20.10.14 docker-compose 1.29.1（文件格式版本3.0，建议安装最新版本） 注意 数据相对独立，本文不涉及数据库安装，建议使用mysql ","date":"2022-05-26","objectID":"/posts/docker-tp5%E9%83%A8%E7%BD%B2/:1:1","series":null,"tags":["Docker","Compose","PHP","Thinkphp"],"title":"Docker+TP5部署","uri":"/posts/docker-tp5%E9%83%A8%E7%BD%B2/#软件版本说明"},{"categories":["运维"],"content":"安装Docker curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 详细教程 ","date":"2022-05-26","objectID":"/posts/docker-tp5%E9%83%A8%E7%BD%B2/:1:2","series":null,"tags":["Docker","Compose","PHP","Thinkphp"],"title":"Docker+TP5部署","uri":"/posts/docker-tp5%E9%83%A8%E7%BD%B2/#安装docker"},{"categories":["运维"],"content":"安装docker-compose 下载最新版的docker-compose文件 sudo curl -L https://github.com/docker/compose/releases/download/1.29.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose 添加可执行权限 sudo chmod +x /usr/local/bin/docker-compose 查看版本 docker-compose -v docker-compose version 1.29.1, build 8dd22a9 ","date":"2022-05-26","objectID":"/posts/docker-tp5%E9%83%A8%E7%BD%B2/:1:3","series":null,"tags":["Docker","Compose","PHP","Thinkphp"],"title":"Docker+TP5部署","uri":"/posts/docker-tp5%E9%83%A8%E7%BD%B2/#安装docker-compose"},{"categories":["运维"],"content":"安装PHP 创建php7.2的docker目录(每个项目支持PHP较为不同，所以版本号命名方便区分) mkdir /docker/php7.2 在php7.2目录下新建docker-compose.yml文件 version: \"3\" services: fpm: build: context: ./ #Dockerfile路径 dockerfile: php7.2_fpm_dockerfile #服务除了可以基于指定的镜像，还可以基于一份Dockerfile，我把Dockerfile放到下面 restart: always networks: - db environment: - TZ=Asia/Shanghai privileged: true volumes: - /home/code/tp5:/var/www/tp5 #挂在程序目录，建议此目录与nginx挂在目录保持一致 networks: db: external: true FROM php:7.2.24-fpm RUN docker-php-ext-install pdo pdo_mysql #增加mysql扩展 启动服务 docker-compose up -d 在/home/code/tp5目录下创建index.php进行测试 ","date":"2022-05-26","objectID":"/posts/docker-tp5%E9%83%A8%E7%BD%B2/:1:4","series":null,"tags":["Docker","Compose","PHP","Thinkphp"],"title":"Docker+TP5部署","uri":"/posts/docker-tp5%E9%83%A8%E7%BD%B2/#安装php"},{"categories":["运维"],"content":"安装Nginx 创建nginx的docker目录 mkdir /docker/nginx 在nginx目录下新建docker-compose.yml文件 version: \"3\" services: nginx: restart: always container_name: nginx image: nginx networks: - db ports: - 80:80 volumes: - ./conf/conf.d:/etc/nginx/conf.d - ./etc/nginx/nginx.conf:/etc/nginx/nginx.conf - ./log:/var/log/nginx - ./wwww:/var/www - /home/code/tp5:/var/www/tp5 #挂在程序目录，建议此目录与php挂在目录保持一致 networks: db: external: true 配置TP5的conf，在/docker/nginx/conf/conf.d下创建tp.conf文件 server { listen 80; listen [::]:80; server_name 127.0.0.1; root /var/www/tp5; index index.html index.htm index.php default.html default.htm default.php; location / { index index.html index.php; if (!-e $request_filename) { rewrite ^(.*)$ /index.php?s=$1 last; break; } } location ~ .*\\.(php|php5)?$ { fastcgi_pass php72_fpm_1:9000; #与docker ps命令列表中的NAMES保持一直 fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param SCRIPT_NAME $fastcgi_script_name; include fastcgi_params; } location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ { expires 30d; } location ~ .*\\.(js|css)?$ { expires 12h; } location ~ /.well-known { allow all; } location ~ /\\. { deny all; } access_log /var/log/nginx/tp5.access.log; error_log /var/log/nginx/tp5.error.log; 启动服务 docker-compose up -d 测试//127.0.0.1/index.php ","date":"2022-05-26","objectID":"/posts/docker-tp5%E9%83%A8%E7%BD%B2/:1:5","series":null,"tags":["Docker","Compose","PHP","Thinkphp"],"title":"Docker+TP5部署","uri":"/posts/docker-tp5%E9%83%A8%E7%BD%B2/#安装nginx"},{"categories":["运维"],"content":"目录结构 ├── docker │ ├── nginx │ │ ├── conf │ │ │ └── conf.d │ │ │ └── tp5.conf │ │ ├── docker-compose.yml │ │ ├── etc │ │ │ └── nginx │ │ │ └── nginx.conf │ │ ├── html │ │ ├── log │ │ │ ├── tp5.access.log │ │ │ └── tp5.error.log │ │ ├── timezone │ │ └── wwww │ ├── php72 │ │ ├── docker-compose.yml │ │ └── php7.2_fpm_dockerfile ","date":"2022-05-26","objectID":"/posts/docker-tp5%E9%83%A8%E7%BD%B2/:1:6","series":null,"tags":["Docker","Compose","PHP","Thinkphp"],"title":"Docker+TP5部署","uri":"/posts/docker-tp5%E9%83%A8%E7%BD%B2/#目录结构"},{"categories":["Web"],"content":"生成hexo文章遇到TypeError: Object.fromEntries is not a function错误 ","date":"2022-04-25","objectID":"/posts/hexo-new-page-fatal-typeerror-object-fromentries-is-not-a-function/:1:0","series":null,"tags":["NodeJs","Hexo"],"title":"hexo new page fatal.(TypeError: Object.fromEntries is not a function)","uri":"/posts/hexo-new-page-fatal-typeerror-object-fromentries-is-not-a-function/#生成hexo文章遇到typeerror-objectfromentries-is-not-a-function错误"},{"categories":["Web"],"content":"排查问题 NodeJs版本过低原因，需要 12.x 以上版本才行，本地版本是10.13 ","date":"2022-04-25","objectID":"/posts/hexo-new-page-fatal-typeerror-object-fromentries-is-not-a-function/:1:1","series":null,"tags":["NodeJs","Hexo"],"title":"hexo new page fatal.(TypeError: Object.fromEntries is not a function)","uri":"/posts/hexo-new-page-fatal-typeerror-object-fromentries-is-not-a-function/#排查问题"},{"categories":["Web"],"content":"处理结果 升级NodeJs，升级方法如下（Linux环境）： 查看版本 node –v 安装n模块 npm install -g n 安装最新的稳定版本 n stable 安装完成后，查看Node的版本，检查升级是否成功 node -v 最后，重新创建hexo即可。 ","date":"2022-04-25","objectID":"/posts/hexo-new-page-fatal-typeerror-object-fromentries-is-not-a-function/:1:2","series":null,"tags":["NodeJs","Hexo"],"title":"hexo new page fatal.(TypeError: Object.fromEntries is not a function)","uri":"/posts/hexo-new-page-fatal-typeerror-object-fromentries-is-not-a-function/#处理结果"}]